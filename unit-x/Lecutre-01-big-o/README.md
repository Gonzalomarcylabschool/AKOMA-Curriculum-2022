#Big O Notation


## What is an algorithm?

An algorithm is a set of instructions that can be followed to accomplish a specific task or solve a problem. Think of it like a recipe for cooking a meal, where each step outlines what needs to be done in order to achieve the final result. Just as a recipe tells you what ingredients to use and in what order to combine them, an algorithm provides a step-by-step process for solving a problem or completing a task.

Let's think of this in terms that we have talked about before. 

Tell me the directions of how to get to campus from your home.

## How do we measure the efficiency of an algorithm?

There are several ways to measure the efficiency of an algorithm, but some common methods include:

Time Complexity: This measures the amount of time an algorithm takes to complete as a function of the size of the input. Common time complexity classes include O(1), O(n), O(log n), and O(n^2).

Space Complexity: This measures the amount of memory an algorithm uses as a function of the size of the input. Like time complexity, space complexity is typically expressed using big O notation.

Number of operations: The number of operations an algorithm performs to solve a problem is another way of measuring its efficiency. For example, a sorting algorithm that uses a simple comparison operation to sort a list is more efficient than one that uses multiple comparison operations.

Approximate/experimental measurements: It could be done by running the algorithm on different inputs of various sizes and measure the execution time.

It's important to note that the most efficient algorithm is not always the best choice, as other factors such as ease of implementation and maintainability should also be considered.
* Why is it important to assess how an algorithm's runtime grows in relation to the size of its input?
* What are common algorithm runtime and how do they describe how and which algorithms are associated with them?

## Key Terms`
* Big-O Notation
* Runtime Complexity
* Space Complexity
* O(1) - constant time
* O(_n_) - linear time
* O(_n_<sup>2</sup>) - quadratic time
* O(log _n_) - log time
* O(_n_ * log _n_) - log linear time
* O(2<sup>_n_</sup>) - exponential time
* O(_n_!) - factorial time